#include <iostream>
#include <locale>
#include "FST.h"

using namespace std;

void executeAndPrint(FST::FST& fst) {
    if (FST::execute(fst)) {
        cout << "Цепочка распознана!" << endl;
    }
    else {
        cout << "Цепочка не распознана." << endl;
    }
}

int main() {
    setlocale(LC_ALL, "rus");

    // для первой
    FST::FST fst1(
        "abcfbg", 9,
        FST::NODE(1, FST::RELATION('a', 1)), //0
        FST::NODE(1, FST::RELATION('b', 2)), //1
        FST::NODE(4, FST::RELATION('c', 3), FST::RELATION('b', 2), FST::RELATION('d', 4), FST::RELATION('e', 5)), //2
        FST::NODE(1, FST::RELATION('f', 6)), //3
        FST::NODE(1, FST::RELATION('f', 6)), //4
        FST::NODE(1, FST::RELATION('f', 6)), //5
        FST::NODE(4, FST::RELATION('e', 5), FST::RELATION('d', 4), FST::RELATION('c', 3), FST::RELATION('b',7)), //6
        FST::NODE(3, FST::RELATION('c',6), FST::RELATION('b', 7), FST::RELATION('g', 8)), //7
        FST::NODE()
    );

    // для второй
    FST::FST fst2(
        "abcfdfcfbg", 9,
        FST::NODE(1, FST::RELATION('a', 1)), //0
        FST::NODE(1, FST::RELATION('b', 2)), //1
        FST::NODE(4, FST::RELATION('c', 3), FST::RELATION('b', 2), FST::RELATION('d', 4), FST::RELATION('e', 5)), //2
        FST::NODE(1, FST::RELATION('f', 6)), //3
        FST::NODE(1, FST::RELATION('f', 6)), //4
        FST::NODE(1, FST::RELATION('f', 6)), //5
        FST::NODE(4, FST::RELATION('e', 5), FST::RELATION('d', 4), FST::RELATION('c', 3), FST::RELATION('b', 7)), //6
        FST::NODE(3, FST::RELATION('c', 6), FST::RELATION('b', 7), FST::RELATION('g', 8)), //7
        FST::NODE()
    );

    // для третьей
    FST::FST fst3(
        "abbbefdfcfbbbg", 9,
        FST::NODE(1, FST::RELATION('a', 1)), //0
        FST::NODE(1, FST::RELATION('b', 2)), //1
        FST::NODE(4, FST::RELATION('c', 3), FST::RELATION('b', 2), FST::RELATION('d', 4), FST::RELATION('e', 5)), //2
        FST::NODE(1, FST::RELATION('f', 6)), //3
        FST::NODE(1, FST::RELATION('f', 6)), //4
        FST::NODE(1, FST::RELATION('f', 6)), //5
        FST::NODE(4, FST::RELATION('e', 5), FST::RELATION('d', 4), FST::RELATION('c', 3), FST::RELATION('b', 7)), //6
        FST::NODE(3, FST::RELATION('c', 6), FST::RELATION('b', 7), FST::RELATION('g', 8)), //7
        FST::NODE()
    );

    cout << "Результат для fst1: ";
    executeAndPrint(fst1);

    cout << "Результат для fst2: ";
    executeAndPrint(fst2);

    cout << "Результат для fst3: ";
    executeAndPrint(fst3);

    return 0;
}

/*
1. **Как называется первая фаза компилятора**
   Первая фаза компилятора называется **лексический анализ** или **лексический разбор**.

2. **Дайте определение лексического анализа**
   Лексический анализ — это процесс преобразования исходного кода в последовательность лексем, где каждая лексема представляет собой наименьшую единицу информации, например, ключевые слова, операторы, идентификаторы.

3. **Какие функции выполняет лексический анализатор**
   Лексический анализатор:
   - Разбивает исходный код на лексемы.
   - Удаляет пробелы, комментарии и другие незначимые символы.
   - Классифицирует лексемы (например, как ключевые слова, операторы или идентификаторы).
   - Обнаруживает и сообщает об ошибках, таких как использование недопустимых символов.

4. **Какая грамматика по иерархии Хомского применяется для описания лексики языка программирования**
   Лексика языка программирования описывается **регулярной грамматикой** (Type-3 по классификации Хомского).

5. **Дайте определение регулярного выражения**
   Регулярное выражение — это последовательность символов, которая задает шаблон для поиска или сопоставления строк с помощью специальных символов и операторов, таких как `*`, `+`, `?`, `[]`, и другие.

6. **Дайте определение конечного автомата**
   Конечный автомат — это математическая модель, состоящая из набора состояний, переходов между ними в зависимости от входных символов, которая используется для распознавания регулярных языков.

7. **Приведите схему работы лексического анализатора**
- чтение
- удаление лишнего
- выделение слов
- преобразование в лексемы

8. **Соотношение регулярного языка, регулярной грамматики и конечного автомата**
   - **Регулярный язык** — это язык, который может быть описан с помощью регулярной грамматики.
   - **Регулярная грамматика** описывает регулярные языки и может быть реализована с помощью конечного автомата.
   - **Конечный автомат** может распознавать регулярные языки, проходя по символам строки и переходя между состояниями в соответствии с правилами грамматики.

9. **Конечный автомат: определение графа переходов конечного автомата и метод его построения по регулярному выражению**
   - **Граф переходов конечного автомата** — это граф, в котором вершины представляют собой состояния автомата, а ребра — возможные переходы между состояниями в зависимости от входных символов.
   - Для построения конечного автомата по регулярному выражению:
     1. Выражение представляется в виде множества состояний и переходов между ними.
     2. Операции объединения (альтернативы), конкатенации и замыкания Клини реализуются как группы состояний и переходов.

10. **Конечный автомат: алгоритм разбора цепочки символов, основанный на двух массивах**
   Алгоритм использует два массива:
   - **Текущие активные состояния** — состояния, в которых находится автомат на текущем шаге разбора.
   - **Следующие активные состояния** — состояния, в которые можно перейти на основе текущего символа.
   1. Изначально в первом массиве хранится начальное состояние автомата.
   2. Для каждого символа строки проверяются возможные переходы из активных состояний.
   3. После обработки символа второй массив становится текущим.
   4. По завершении разбора проверяется, находится ли автомат в конечном состоянии.
*/